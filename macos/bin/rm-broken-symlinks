#!/usr/bin/env python3

"""
Script to remove broken symlinks recursively in a directory
Usage: python remove_broken_symlinks.py [OPTIONS] [DIRECTORY]
"""

import os
import sys
import argparse
from pathlib import Path
from datetime import datetime


def log(message, verbose=False):
    """Log messages with timestamp if verbose mode is enabled"""
    if verbose:
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"[{timestamp}] {message}", file=sys.stderr)


def find_broken_symlinks(directory):
    """
    Generator that yields broken symlinks in the given directory recursively

    Args:
        directory (Path): Directory to search

    Yields:
        Path: Broken symlink paths
    """
    try:
        for item in directory.rglob("*"):
            if item.is_symlink() and not item.exists():
                yield item
    except PermissionError as e:
        print(f"Warning: Permission denied accessing {e.filename}", file=sys.stderr)


def process_broken_symlinks(directory, dry_run=False, verbose=False):
    """
    Find and process broken symlinks in the given directory

    Args:
        directory (Path): Directory to search
        dry_run (bool): If True, only show what would be deleted
        verbose (bool): If True, show verbose output

    Returns:
        int: Number of broken symlinks found/removed
    """
    directory = Path(directory).resolve()

    log(f"Searching for broken symlinks in: {directory}", verbose)

    count = 0
    broken_symlinks = list(find_broken_symlinks(directory))

    for symlink in broken_symlinks:
        try:
            if dry_run:
                print(f"Would remove: {symlink}")
            else:
                print(f"Removing: {symlink}")
                symlink.unlink()
            count += 1
        except OSError as e:
            print(f"Error processing {symlink}: {e}", file=sys.stderr)

    # Summary
    if count == 0:
        print("No broken symlinks found.")
    else:
        if dry_run:
            print(f"Found {count} broken symlink(s) that would be removed.")
        else:
            print(f"Successfully removed {count} broken symlink(s).")

    log("Operation completed", verbose)
    return count


def main():
    """Main function to handle command line arguments and execute the script"""
    parser = argparse.ArgumentParser(
        description="Remove broken symlinks recursively in the specified directory.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s                        # Remove broken symlinks in current directory
  %(prog)s -d                     # Dry run in current directory
  %(prog)s -v /path/to/dir        # Remove with verbose output in specific directory
  %(prog)s -dv /path/to/dir       # Dry run with verbose output
        """,
    )

    parser.add_argument(
        "directory",
        nargs="?",
        default=".",
        help="Directory to search (default: current directory)",
    )

    parser.add_argument(
        "-d",
        "--dry-run",
        action="store_true",
        help="Show what would be deleted without actually deleting",
    )

    parser.add_argument(
        "-v", "--verbose", action="store_true", help="Show verbose output"
    )

    args = parser.parse_args()

    # Validate directory
    directory_path = Path(args.directory)
    if not directory_path.exists():
        print(f"Error: Directory '{args.directory}' does not exist", file=sys.stderr)
        sys.exit(1)

    if not directory_path.is_dir():
        print(f"Error: '{args.directory}' is not a directory", file=sys.stderr)
        sys.exit(1)

    # Show configuration
    if args.dry_run:
        print("DRY RUN MODE - No files will be deleted")

    log(f"Directory: {directory_path.resolve()}", args.verbose)
    log(f"Dry run: {args.dry_run}", args.verbose)
    log(f"Verbose: {args.verbose}", args.verbose)

    try:
        # Process broken symlinks
        count = process_broken_symlinks(args.directory, args.dry_run, args.verbose)
        sys.exit(0)
    except KeyboardInterrupt:
        print("\nOperation cancelled by user", file=sys.stderr)
        sys.exit(130)
    except Exception as e:
        print(f"Unexpected error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
